\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{fancyvrb}

\mode<beamer>{%
\setbeamertemplate{footline}[text line]{%
  \parbox{\linewidth}{\vspace*{-64pt}https://cobordism.com}}}
\mode<beamer>{%
\setbeamertemplate{navigation symbols}{}}

\title{Who's Afraid of the Big Bad ceval Loop?}
\subtitle{Me}
\author{Moshe Zadka -- https://cobordism.com}
\date{2020}

\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}

\frame{\titlepage}

\begin{frame}
\frametitle{What is not the eval loop?}
\end{frame}

The CPython interpreter,
as its name implies,
is writen in C.
It contains several parts,
which we will not delve into today.
It has the parser and byte compiler,
which produce Python byte code.
It also has the implementation of
native objects,
such as integers as strings,
as C
"extension classes".

The eval loop does not do any parsing or byte-code compilation.
Those steps must have been done before:
usually,
Python will do them for us
(although we can force it to execute on a sequence
of byte codes).
It also does not have any of Python's
*object*
semantics:
it does not know that one integer divided by another must sometimes
result in a floating point number,
or that strings are immutable.

The semantics of Python's
*objects*
are part of the class definitions:
this is where integer division
or string modification
(resulting in an error)
are implemented.

\begin{frame}
\frametitle{What is the eval loop?}

\begin{lstlisting}
for (;;) {
    /* ... */
    /* This is a lie */
    opcode = (*next_instr) & 0xff;
    oparg = (*next_instr) >> 8;
    next_instr++;
    /* ... */
    switch (opcode) {
        /* ... */
    }
}
\end{lstlisting}

\end{frame}

In the middle between those parts,
something must
*actually execute*
the byte-code.
When we have a sequence of byte codes,
something must inspect the code,
decide which operation to do,
and do it.

As this description might imply,
this is one of the most performance critical parts
in the CPython interpreter.
The eval loop has seen many generations of iterations,
and has evolved together with CPU architecture.
This is the reason for the white lie above:
the actual code is a few layers of macros,
including an ifdef based on the machine architecture.


\begin{frame}[fragile]
\frametitle{Code objects}

\begin{lstlisting}
>>> (lambda x:None).__code__
<code object <lambda> at 0x7fb7b67725d0, file "<stdin>", line 1>
\end{lstlisting}

\end{frame}

Code objects are usually found in functions,
as the \verb|__code__| attribute.

\begin{frame}
\frametitle{Python bytecode}

\begin{lstlisting}
>>> (lambda a, b: a + b
... ).__code__.co_code
b'|\x00|\x01\x17\x00S\x00'
>>> dis.dis(_)
          0 LOAD_FAST                0 (0)
          2 LOAD_FAST                1 (1)
          4 BINARY_ADD
          6 RETURN_VALUE
\end{lstlisting}

\end{frame}

Python bytecode are...
bytes.
They come in sequence of two:
a code,
and then an argument.
For codes that do not need an argument,
the argument will be NIL,
the 0 byte.

\begin{frame}
\frametitle{Frame}

Where the eval happens
\end{frame}

Python bytecode always happens in the context of a
{\em frame}.
A frame gives context to code.
Calling a function will
*create*
a frame.
Naturally,
distinct calls to the function
will generate distinct frames.
This is how recursion can work.

Frames are explicit,
though not documented,
in Python.
The current frame can always be retrieved by
\verb|sys._getframe()|.
While it should never be done in
"real"
code,
it is a great exercise to play with it.
It also serves as a useful thing in debuggers
and other coding tools.

\begin{frame}
\frametitle{Frame contents}

Code and context
\end{frame}

Since code evaluation always happen in the context of a
*frame*,
the frame holds the code.
It also holds several links to namespaces:
the locals, the globals, and the builtins.
Finally,
frames are
*nested*:
a frame will have a link to the "outer",
or "back",
frame.



\begin{frame}
\frametitle{Frame inspection}

\begin{lstlisting}
>>> def foo(): bar()
... 
>>> def bar():
...     global frm;frm = sys._getframe()
... 
>>> frm.f_code.co_name
'bar'
>>> frm.f_back.f_code.co_name
'foo'
>>> frm.f_back.f_back.f_code.co_name
'<module>'
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Stack machine}
\end{frame}

\begin{frame}
\frametitle{Stack structure}
\end{frame}

\begin{frame}
\frametitle{Stack operations}
\end{frame}

\begin{frame}[fragile]
\frametitle{The Loop}
\verb|PyEval_EvalFrameDefault|
\end{frame}

\begin{frame}
\frametitle{The Two Halves}
Prelude vs. switch
\end{frame}

\begin{frame}
\frametitle{Eval Breaker}
\end{frame}

\begin{frame}
\frametitle{Signal handling}
\end{frame}

\begin{frame}
\frametitle{Signals: recording pending}
\end{frame}

\begin{frame}
\frametitle{Signals: calling handlers}
\end{frame}

\begin{frame}
\frametitle{Global Interpreter Lock}
\end{frame}

\begin{frame}
\frametitle{GIL: Acquisition}
\end{frame}

\begin{frame}
\frametitle{GIL: Release}
\end{frame}

\begin{frame}
\frametitle{GIL: Drop request}
\end{frame}

\begin{frame}
\frametitle{What is branch prediction?}
\end{frame}

\begin{frame}
\frametitle{What are computed gotos?}
\end{frame}

\begin{frame}
\frametitle{What is the "threaded code" optimization?}
\end{frame}

\begin{frame}
\frametitle{Takeaways}
\end{frame}

\end{document}
