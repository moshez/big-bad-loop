\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{fancyvrb}

\mode<beamer>{%
\setbeamertemplate{footline}[text line]{%
  \parbox{\linewidth}{\vspace*{-64pt}https://cobordism.com}}}
\mode<beamer>{%
\setbeamertemplate{navigation symbols}{}}

\title{Who's Afraid of the Big Bad ceval Loop?}
\subtitle{Me}
\author{Moshe Zadka -- https://cobordism.com}
\date{2020}

\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}

\frame{\titlepage}

\begin{frame}
\frametitle{What is not the eval loop?}
\end{frame}

The CPython interpreter,
as its name implies,
is writen in C.
It contains several parts,
which we will not delve into today.
It has the parser and byte compiler,
which produce Python byte code.
It also has the implementation of
native objects,
such as integers as strings,
as C
"extension classes".

The eval loop does not do any parsing or byte-code compilation.
Those steps must have been done before:
usually,
Python will do them for us
(although we can force it to execute on a sequence
of byte codes).
It also does not have any of Python's
*object*
semantics:
it does not know that one integer divided by another must sometimes
result in a floating point number,
or that strings are immutable.

The semantics of Python's
*objects*
are part of the class definitions:
this is where integer division
or string modification
(resulting in an error)
are implemented.

\begin{frame}
\frametitle{What is the eval loop?}

\begin{lstlisting}
for (;;) {
    /* ... */
    /* This is a lie */
    opcode = (*next_instr) & 0xff;
    oparg = (*next_instr) >> 8;
    next_instr++;
    /* ... */
    switch (opcode) {
        /* ... */
    }
}
\end{lstlisting}

\end{frame}

In the middle between those parts,
something must
*actually execute*
the byte-code.
When we have a sequence of byte codes,
something must inspect the code,
decide which operation to do,
and do it.

As this description might imply,
this is one of the most performance critical parts
in the CPython interpreter.
The eval loop has seen many generations of iterations,
and has evolved together with CPU architecture.
This is the reason for the white lie above:
the actual code is a few layers of macros,
including an ifdef based on the machine architecture.


\begin{frame}
\frametitle{Byte compiling}
\end{frame}

\begin{frame}
\frametitle{Code objects}
\end{frame}

\begin{frame}
\frametitle{Python bytecode}
\end{frame}

\begin{frame}
\frametitle{Frame}
\end{frame}

\begin{frame}
\frametitle{Frame contents}
\end{frame}

\begin{frame}
\frametitle{Frame inspection}
\end{frame}

\begin{frame}
\frametitle{Stack machine}
\end{frame}

\begin{frame}
\frametitle{Stack structure}
\end{frame}

\begin{frame}
\frametitle{Stack operations}
\end{frame}

\begin{frame}[fragile]
\frametitle{The Loop}
\verb|PyEval_EvalFrameDefault|
\end{frame}

\begin{frame}
\frametitle{The Two Halves}
Prelude vs. switch
\end{frame}

\begin{frame}
\frametitle{Eval Breaker}
\end{frame}

\begin{frame}
\frametitle{Signal handling}
\end{frame}

\begin{frame}
\frametitle{Signals: recording pending}
\end{frame}

\begin{frame}
\frametitle{Signals: calling handlers}
\end{frame}

\begin{frame}
\frametitle{Global Interpreter Lock}
\end{frame}

\begin{frame}
\frametitle{GIL: Acquisition}
\end{frame}

\begin{frame}
\frametitle{GIL: Release}
\end{frame}

\begin{frame}
\frametitle{GIL: Drop request}
\end{frame}

\begin{frame}
\frametitle{What is branch prediction?}
\end{frame}

\begin{frame}
\frametitle{What are computed gotos?}
\end{frame}

\begin{frame}
\frametitle{What is the "threaded code" optimization?}
\end{frame}

\begin{frame}
\frametitle{Takeaways}
\end{frame}

\end{document}
