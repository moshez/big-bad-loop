\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{fancyvrb}

\mode<beamer>{%
\setbeamertemplate{footline}[text line]{%
  \parbox{\linewidth}{\vspace*{-64pt}https://cobordism.com}}}
\mode<beamer>{%
\setbeamertemplate{navigation symbols}{}}

\title{Who's Afraid of the Big Bad ceval Loop?}
\subtitle{Me}
\author{Moshe Zadka -- https://cobordism.com}
\date{2020}

\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}

\frame{\titlepage}

\begin{frame}
\frametitle{What is not the eval loop?}
\end{frame}

The CPython interpreter,
as its name implies,
is writen in C.
It contains several parts,
which we will not delve into today.
It has the parser and byte compiler,
which produce Python byte code.
It also has the implementation of
native objects,
such as integers as strings,
as C
"extension classes".

The eval loop does not do any parsing or byte-code compilation.
Those steps must have been done before:
usually,
Python will do them for us
(although we can force it to execute on a sequence
of byte codes).
It also does not have any of Python's
*object*
semantics:
it does not know that one integer divided by another must sometimes
result in a floating point number,
or that strings are immutable.

The semantics of Python's
*objects*
are part of the class definitions:
this is where integer division
or string modification
(resulting in an error)
are implemented.

\begin{frame}
\frametitle{What is the eval loop?}

\begin{lstlisting}
for (;;) {
    /* ... */
    /* This is a lie */
    opcode = (*next_instr) & 0xff;
    oparg = (*next_instr) >> 8;
    next_instr++;
    /* ... */
    switch (opcode) {
        /* ... */
    }
}
\end{lstlisting}

\end{frame}

In the middle between those parts,
something must
*actually execute*
the byte-code.
When we have a sequence of byte codes,
something must inspect the code,
decide which operation to do,
and do it.

As this description might imply,
this is one of the most performance critical parts
in the CPython interpreter.
The eval loop has seen many generations of iterations,
and has evolved together with CPU architecture.
This is the reason for the white lie above:
the actual code is a few layers of macros,
including an ifdef based on the machine architecture.


\begin{frame}[fragile]
\frametitle{Code objects}

\begin{lstlisting}
>>> (lambda x:None).__code__
<code object <lambda> at 0x7fb7b67725d0, file "<stdin>", line 1>
\end{lstlisting}

\end{frame}

Code objects are usually found in functions,
as the \verb|__code__| attribute.

\begin{frame}
\frametitle{Python bytecode}

\begin{lstlisting}
>>> (lambda a, b: a + b
... ).__code__.co_code
b'|\x00|\x01\x17\x00S\x00'
>>> dis.dis(_)
          0 LOAD_FAST                0 (0)
          2 LOAD_FAST                1 (1)
          4 BINARY_ADD
          6 RETURN_VALUE
\end{lstlisting}

\end{frame}

Python bytecode are...
bytes.
They come in sequence of two:
a code,
and then an argument.
For codes that do not need an argument,
the argument will be NIL,
the 0 byte.

\begin{frame}
\frametitle{Frame}

Where the eval happens
\end{frame}

Python bytecode always happens in the context of a
{\em frame}.
A frame gives context to code.
Calling a function will
*create*
a frame.
Naturally,
distinct calls to the function
will generate distinct frames.
This is how recursion can work.

Frames are explicit,
though not documented,
in Python.
The current frame can always be retrieved by
\verb|sys._getframe()|.
While it should never be done in
"real"
code,
it is a great exercise to play with it.
It also serves as a useful thing in debuggers
and other coding tools.

\begin{frame}
\frametitle{Frame contents}

Code and context
\end{frame}

Since code evaluation always happen in the context of a
*frame*,
the frame holds the code.
It also holds several links to namespaces:
the locals, the globals, and the builtins.
Finally,
frames are
*nested*:
a frame will have a link to the "outer",
or "back",
frame.



\begin{frame}
\frametitle{Frame inspection}

\begin{lstlisting}
>>> def foo(): bar()
... 
>>> def bar():
...     global frm;frm = sys._getframe()
... 
>>> frm.f_code.co_name
'bar'
>>> frm.f_back.f_code.co_name
'foo'
>>> frm.f_back.f_back.f_code.co_name
'<module>'
\end{lstlisting}
\end{frame}

The frames have a link to the "back frame",
where a "return" statement or a "yield" statement would go.
This explicit structure of frames is an essential part of allowing
generators and other more complicated control structures.
They also have a link to the code object.
Frames also have an \verb|f_lasti| property,
which contains an index to the last instruction.
This is the variable that the eval loop increments.

\begin{frame}
\frametitle{Stack machine}

\begin{lstlisting}
PyObject **stack_pointer;
/* ... */
#define BASIC_PUSH(v)     (*stack_pointer++ = (v))
#define BASIC_POP()       (*--stack_pointer)
\end{lstlisting}
\end{frame}

The basic semantics of Python's byte code are those of a stack machine.
The operations all operate on a stack:
it can be pushed or popped,
and operations happen on the stack.
The stack space is part of the frame.
This means that a frame suspended,
for example when yielding,
still has the stack.

\begin{frame}
\frametitle{Stack operations}

\begin{lstlisting}
#define TOP()             (stack_pointer[-1])
#define PEEK(n)           (stack_pointer[-(n)])
#define SET_TOP(v)        (stack_pointer[-1] = (v))
\end{lstlisting}
\end{frame}

The Python implementation defines some macros for highly
efficient stack operations. This is important,
since much of what Python does involves manipulatig the
stack.

\begin{frame}[fragile]
\frametitle{The Loop}

\begin{lstlisting}
PyObject *_PyEval_EvalFrameDefault(PyFrameObject *f, int throwflag)
{
    /* ... */
    /* Small lie */
    next_instr = f->f_code->co_code + f->f_lasti;
    for (;;) {
        /* ... */
        /* Small lie */
    fast_next_opcode:
        opcode = (*next_instr) & 0xff;
        oparg = (*next_instr) >> 8;
        next_instr++;
        switch (opcode) {
            /* ... */
        }
    }
    error:
        /* ... */
}
\end{lstlisting}
\end{frame}

This is the Python eval loop.
We initialize the insturction pointer to the current place based
on the frame
(in case it needs to be resumed).
The lies are because I simplified the code, and made it less efficient,
but equivalent. Python is highly optimized, but that can obscure
the semantics.


\begin{frame}
\frametitle{The Switch}
\begin{lstlisting}
 switch (opcode) {
        /* ... */
        case TARGET(LOAD_FAST): {
            PyObject *value = GETLOCAL(oparg);
            if (value == NULL) {
                /* ... */
                goto error;
            }
            /* ... */
            goto fast_next_opcode;
        }
        /* ... */
        case TARGET(UNARY_NEGATIVE): {
            /* ... */
            continue;
        }
        /* ... */
}
\end{lstlisting}
\end{frame}

Every instruction handle finishes with one of three:
either it goes to an error, or it does a
"fast"
or
"slow"
dispatch.
"Fast" dispatches are those that skip various checks:
for example,
thread switches cannot happen between a "fast" dispatch
and the one that follows.

\begin{frame}
\frametitle{Eval Breaker}
\end{frame}

\begin{frame}
\frametitle{Signal handling}
\end{frame}

\begin{frame}
\frametitle{Signals: recording pending}
\end{frame}

\begin{frame}
\frametitle{Signals: calling handlers}
\end{frame}

\begin{frame}
\frametitle{Global Interpreter Lock}
\end{frame}

\begin{frame}
\frametitle{GIL: Acquisition}
\end{frame}

\begin{frame}
\frametitle{GIL: Release}
\end{frame}

\begin{frame}
\frametitle{GIL: Drop request}
\end{frame}

\begin{frame}
\frametitle{What is branch prediction?}
\end{frame}

\begin{frame}
\frametitle{What are computed gotos?}
\end{frame}

\begin{frame}
\frametitle{What is the "threaded code" optimization?}
\end{frame}

\begin{frame}
\frametitle{Takeaways}
\end{frame}

\end{document}
